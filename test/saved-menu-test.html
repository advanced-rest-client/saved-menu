<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">

    <script src="../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../node_modules/@polymer/test-fixture/test-fixture.js"></script>
    <script src="../node_modules/mocha/mocha.js"></script>
    <script src="../node_modules/chai/chai.js"></script>
    <script src="../node_modules/wct-mocha/wct-mocha.js"></script>

  </head>
  <body>

    <test-fixture id="Basic">
      <template>
        <saved-menu no-auto></saved-menu>
      </template>
    </test-fixture>

    <test-fixture id="Models">
      <template>
        <request-model></request-model>
        <project-model></project-model>
        <saved-menu></saved-menu>
      </template>
    </test-fixture>

    <test-fixture id="Draggable">
      <template>
        <saved-menu no-auto draggable-enabled></saved-menu>
      </template>
    </test-fixture>

    <script type="module">
    import sinon from '../../../sinon/pkg/sinon-esm.js';
    import '../../../@advanced-rest-client/arc-models/request-model.js';
    import '../../../@advanced-rest-client/arc-models/project-model.js';
    import {DataGenerator} from '../../../@advanced-rest-client/arc-data-generator/arc-data-generator.js';
    import {afterNextRender} from '../../../@polymer/polymer/lib/utils/render-status.js';
    import '../saved-menu.js';

    /* global DataTransfer */
    // DataTransfer polyfill
    if (typeof DataTransfer === 'undefined') {
      class DataTransfer {
        setData(type, data) {
          this._data[type] = data;
        }
        getData(type) {
          if (!this._data) {
            return null;
          }
          return this._data[type];
        }
      }
      window.DataTransfer = DataTransfer;
    }

    suite('saved-menu', function() {
      suite('_computeA11yCommand()', () => {
        let element;
        setup(function() {
          element = fixture('Basic');
        });

        test('Returns passed letter with CMD/CTRL', () => {
          const result = element._computeA11yCommand('s');
          assert.isTrue(/(meta|ctrl)\+s/.test(result));
        });
      });

      suite('notifyResize()', () => {
        test('Do nothing when DOM is not initialized', () => {
          const element = fixture('Basic');
          element.notifyResize();
        });

        test('Calls list\'s notifyResize', (done) => {
          const element = fixture('Basic');
          flush(() => {
            const list = element.$.list;
            let called = false;
            list.notifyResize = () => called = true;
            element.notifyResize();
            assert.isTrue(called);
            done();
          });
        });

        test('Do nothing when DOM not ready', () => {
          const element = fixture('Basic');
          const old = element.$;
          element.$ = undefined;
          element.notifyResize();
          element.$ = old;
          // no error
        });
      });

      suite('_scrollHandler()', () => {
        let element;
        setup(function() {
          element = fixture('Basic');
        });

        test('Calls loadNext() when called', () => {
          let called = false;
          element.loadNext = () => called = true;
          element._scrollHandler();
          assert.isTrue(called);
        });
      });

      suite('_openSaved()', () => {
        let element;
        let eModel;
        setup(function() {
          element = fixture('Basic');
          eModel = {
            model: {
              get() {
                return 'test';
              }
            }
          };
        });

        test('Dispatches navigate event', () => {
          const spy = sinon.spy();
          element.addEventListener('navigate', spy);
          element._openSaved(eModel);
          assert.isTrue(spy.called);
        });

        test('The event has base', () => {
          let data;
          element.addEventListener('navigate', function f(e) {
            element.removeEventListener('navigate', f);
            data = e.detail;
          });
          element._openSaved(eModel);
          assert.equal(data.base, 'request');
        });

        test('The event has type', () => {
          let data;
          element.addEventListener('navigate', function f(e) {
            element.removeEventListener('navigate', f);
            data = e.detail;
          });
          element._openSaved(eModel);
          assert.equal(data.type, 'saved');
        });

        test('The event has id', () => {
          let data;
          element.addEventListener('navigate', function f(e) {
            element.removeEventListener('navigate', f);
            data = e.detail;
          });
          element._openSaved(eModel);
          assert.equal(data.id, 'test');
        });

        test('The event bubbles', () => {
          let data;
          element.addEventListener('navigate', function f(e) {
            element.removeEventListener('navigate', f);
            data = e;
          });
          element._openSaved(eModel);
          assert.isTrue(data.bubbles);
        });

        test('The event is composed', () => {
          let data;
          element.addEventListener('navigate', function f(e) {
            element.removeEventListener('navigate', f);
            data = e;
          });
          element._openSaved(eModel);
          assert.isTrue(data.composed);
        });

        test('The event is cancelable', () => {
          let data;
          element.addEventListener('navigate', function f(e) {
            element.removeEventListener('navigate', f);
            data = e;
          });
          element._openSaved(eModel);
          assert.isTrue(data.cancelable);
        });
      });
    });
    suite('DOM manipulation', () => {
      function doneAfterQuery(element, done) {
        element.addEventListener('querying-changed', function f(e) {
          if (e.detail.value) {
            return;
          }
          element.removeEventListener('querying-changed', f);
          flush(() => done());
        });
      }

      suite('No data', () => {
        suiteSetup(() => {
          return DataGenerator.destroySavedRequestData();
        });

        let element;
        setup((done) => {
          element = fixture('Models')[2];
          doneAfterQuery(element, done);
        });

        test('hasRequests is false', () => {
          assert.isFalse(element.hasRequests);
        });

        test('empty message is rendered', () => {
          const node = element.shadowRoot.querySelector('.empty-message');
          assert.ok(node);
        });

        test('The list is hidden', () => {
          assert.isTrue(element.$.list.hasAttribute('hidden'));
        });
      });

      suite('With data', () => {
        suiteSetup(() => {
          return DataGenerator.insertSavedRequestData();
        });

        suiteTeardown(() => {
          return DataGenerator.destroySavedRequestData();
        });

        let element;
        setup((done) => {
          element = fixture('Models')[2];
          doneAfterQuery(element, done);
        });

        test('hasRequests is true', () => {
          assert.isTrue(element.hasRequests);
        });

        test('empty message is not rendered', () => {
          const node = element.shadowRoot.querySelector('.empty-message');
          const display = getComputedStyle(node).display;
          assert.equal(display, 'none');
        });

        test('The list is visible hidden', () => {
          assert.isFalse(element.$.list.hasAttribute('hidden'));
        });
      });

      suite('_computeDraggableValue()', () => {
        let element;
        setup(function() {
          element = fixture('Basic');
        });

        test('Returns "true" when draggableEnabled is set', () => {
          const result = element._computeDraggableValue(true);
          assert.equal(result, 'true');
        });

        test('Returns "false" when draggableEnabled is not set', () => {
          const result = element._computeDraggableValue(false);
          assert.equal(result, 'false');
        });

        test('Request item has dragging disabled by default', (done) => {
          element.requests = [DataGenerator.generateSavedItem()];
          flush(() => {
            const node = element.shadowRoot.querySelector('paper-icon-item');
            assert.equal(node.getAttribute('draggable'), 'false');
            done();
          });
        });

        test('Request item has dragging enabled', (done) => {
          element.draggableEnabled = true;
          element.requests = [DataGenerator.generateSavedItem()];
          flush(() => {
            const node = element.shadowRoot.querySelector('paper-icon-item');
            assert.equal(node.getAttribute('draggable'), 'true');
            done();
          });
        });
      });

      suite('_dragStart()', () => {
        let element;
        setup(function(done) {
          element = fixture('Draggable');
          element.requests = DataGenerator.generateRequests({
            requestsSize: 2
          });
          // next frame by saved-list-mixin
          afterNextRender(element, () => {
            // database query
            setTimeout(() => {
              // Polymer stamp
              flush(() => done());
            });
          });
        });

        function dispatch(element) {
          const node = element.shadowRoot.querySelector('paper-icon-item');
          const e = new Event('dragstart');
          e.dataTransfer = new DataTransfer();
          node.dispatchEvent(e);
        }

        test('Calls _dragStart()', () => {
          const spy = sinon.spy(element, '_dragStart');
          dispatch(element);
          assert.isTrue(spy.called);
        });

        test('Sets arc/request-object transfer data', () => {
          const spy = sinon.spy(element, '_dragStart');
          dispatch(element);
          const data = spy.args[0][0].dataTransfer.getData('arc/request-object');
          assert.typeOf(data, 'string');
        });

        test('Sets arc/saved-request transfer data', () => {
          const spy = sinon.spy(element, '_dragStart');
          dispatch(element);
          const data = spy.args[0][0].dataTransfer.getData('arc/saved-request');
          assert.equal(data, element.requests[0]._id);
        });

        test('Sets arc-source/saved-menu transfer data', () => {
          const spy = sinon.spy(element, '_dragStart');
          dispatch(element);
          const data = spy.args[0][0].dataTransfer.getData('arc-source/saved-menu');
          assert.equal(data, element.requests[0]._id);
        });

        test('Ignores event when draggableEnabled not set', () => {
          element.draggableEnabled = false;
          const spy = sinon.spy(element, '_dragStart');
          dispatch(element);
          assert.isUndefined(spy.args[0][0].dropEffect);
        });
      });
    });

    suite('_dragoverHandler()', () => {
      let element;
      setup(function() {
        element = fixture('Draggable');
      });

      function dispatch(element, types) {
        if (!types) {
          types = ['arc/request-object'];
        }
        const e = new Event('dragover', {cancelable: true});
        e.dataTransfer = new DataTransfer();
        types.forEach((type) => {
          e.dataTransfer.setData(type, 'test');
        });
        element.dispatchEvent(e);
        return e;
      }

      test('Ignores event when draggableEnabled is not set', () => {
        element.draggableEnabled = false;
        element._dragoverHandler();
        // no error
      });

      test('Ignores event when arc/request-object is not set', () => {
        dispatch(element, ['other']);
        assert.isFalse(element.classList.contains('drop-target'));
      });

      test('Ignores event when arc/saved-request is set', () => {
        dispatch(element, ['arc/saved-request']);
        assert.isFalse(element.classList.contains('drop-target'));
      });

      test('Cancels the event', () => {
        const e = dispatch(element);
        assert.isTrue(e.defaultPrevented);
      });

      test('Sets drop-target class on the element', () => {
        dispatch(element);
        assert.isTrue(element.classList.contains('drop-target'));
      });

      test('Sets class name only once', () => {
        element.classList.add('drop-target');
        dispatch(element);
        assert.isTrue(element.classList.contains('drop-target'));
      });
    });

    suite('_dragleaveHandler()', () => {
      let element;
      setup(function() {
        element = fixture('Draggable');
      });

      function dispatch(element, types) {
        if (!types) {
          types = ['arc/request-object'];
        }
        const e = new Event('dragleave', {cancelable: true});
        e.dataTransfer = new DataTransfer();
        types.forEach((type) => {
          e.dataTransfer.setData(type, 'test');
        });
        element.dispatchEvent(e);
        return e;
      }

      test('Ignores event when draggableEnabled is not set', () => {
        element.draggableEnabled = false;
        element._dragleaveHandler();
        // no error
      });

      test('Ignores event when arc/request-object is not set', () => {
        dispatch(element, ['other']);
        assert.isFalse(element.classList.contains('drop-target'));
      });

      test('Ignores event when arc/saved-request is set', () => {
        dispatch(element, ['arc/saved-request']);
        assert.isFalse(element.classList.contains('drop-target'));
      });

      test('Cancels the event', () => {
        const e = dispatch(element);
        assert.isTrue(e.defaultPrevented);
      });

      test('Removes drop-target class on the element', () => {
        element.classList.add('drop-target');
        dispatch(element);
        assert.isFalse(element.classList.contains('drop-target'));
      });

      test('Removes class name only once', () => {
        dispatch(element);
        assert.isFalse(element.classList.contains('drop-target'));
      });
    });

    suite('_dropHandler()', () => {
      let element;
      setup(function() {
        element = fixture('Draggable');
      });

      function dispatch(element, types, content) {
        if (!types) {
          types = ['arc/request-object'];
        }
        if (content === undefined) {
          content = '{"_id":"test-id", "_rev":"test-rev"}';
        }
        const e = new Event('drop', {cancelable: true});
        e.dataTransfer = new DataTransfer();
        types.forEach((type) => {
          e.dataTransfer.setData(type, content);
        });
        element.dispatchEvent(e);
        return e;
      }

      test('Ignores event when draggableEnabled is not set', () => {
        element.draggableEnabled = false;
        element._dropHandler();
        // no error
      });

      test('Ignores event when arc/request-object is not set', () => {
        dispatch(element, ['other']);
        assert.isFalse(element.classList.contains('drop-target'));
      });

      test('Ignores event when arc/saved-request is set', () => {
        dispatch(element, ['arc/saved-request']);
        assert.isFalse(element.classList.contains('drop-target'));
      });

      test('Cancels the event', () => {
        const e = dispatch(element);
        assert.isTrue(e.defaultPrevented);
      });

      test('Removes drop-target class on the element', () => {
        element.classList.add('drop-target');
        dispatch(element);
        assert.isFalse(element.classList.contains('drop-target'));
      });

      test('Removes class name only once', () => {
        dispatch(element);
        assert.isFalse(element.classList.contains('drop-target'));
      });

      test('Calls _appendRequest() with request', () => {
        element._appendRequest = () => {};
        const spy = sinon.spy(element, '_appendRequest');
        dispatch(element);
        assert.deepEqual(spy.args[0][0], {
          _id: 'test-id',
          _rev: 'test-rev'
        });
      });

      test('Ignores when no request object data', () => {
        const spy = sinon.spy(element, '_appendRequest');
        dispatch(element, null, '');
        assert.isFalse(spy.called);
      });
    });

    suite('_appendRequest()', () => {
      let element;
      setup(function() {
        element = fixture('Draggable');
      });

      test('Removes `_id`', () => {
        const obj = {_id: 'test'};
        element._appendRequest(obj);
        assert.isUndefined(obj._id);
      });

      test('Removes `_rev`', () => {
        const obj = {_rev: 'test'};
        element._appendRequest(obj);
        assert.isUndefined(obj._rev);
      });

      test('Adds default name', () => {
        const obj = {};
        element._appendRequest(obj);
        assert.equal(obj.name, 'Unnamed');
      });

      test('Keeps existing name', () => {
        const obj = {name: 'test'};
        element._appendRequest(obj);
        assert.equal(obj.name, 'test');
      });

      test('Calls dispatch with request', () => {
        const spy = sinon.spy(element, '_dispatch');
        const obj = {name: 'test'};
        element._appendRequest(obj);
        assert.equal(spy.args[0][0], 'save-request');
        assert.deepEqual(spy.args[0][1].request, obj);
      });
    });
    </script>
  </body>
</html>
